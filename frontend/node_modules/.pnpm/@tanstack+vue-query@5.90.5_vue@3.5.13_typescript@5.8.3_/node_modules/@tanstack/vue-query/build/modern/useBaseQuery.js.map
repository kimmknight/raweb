{"version":3,"sources":["../../src/useBaseQuery.ts"],"sourcesContent":["import {\n  computed,\n  getCurrentScope,\n  onScopeDispose,\n  reactive,\n  readonly,\n  shallowReactive,\n  shallowReadonly,\n  toRefs,\n  watch,\n} from 'vue-demi'\nimport { shouldThrowError } from '@tanstack/query-core'\nimport { useQueryClient } from './useQueryClient'\nimport { cloneDeepUnref, updateState } from './utils'\nimport type { Ref } from 'vue-demi'\nimport type {\n  DefaultedQueryObserverOptions,\n  QueryKey,\n  QueryObserver,\n  QueryObserverResult,\n} from '@tanstack/query-core'\nimport type { QueryClient } from './queryClient'\nimport type { UseQueryOptions } from './useQuery'\nimport type { UseInfiniteQueryOptions } from './useInfiniteQuery'\nimport type { MaybeRefOrGetter } from './types'\n\nexport type UseBaseQueryReturnType<\n  TData,\n  TError,\n  TResult = QueryObserverResult<TData, TError>,\n> = {\n  [K in keyof TResult]: K extends\n    | 'fetchNextPage'\n    | 'fetchPreviousPage'\n    | 'refetch'\n    ? TResult[K]\n    : Ref<Readonly<TResult>[K]>\n} & {\n  suspense: () => Promise<TResult>\n}\n\ntype UseQueryOptionsGeneric<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey = QueryKey,\n  TPageParam = unknown,\n> =\n  | UseQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey>\n  | UseInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>\n\nexport function useBaseQuery<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryData,\n  TQueryKey extends QueryKey,\n  TPageParam,\n>(\n  Observer: typeof QueryObserver,\n  options: MaybeRefOrGetter<\n    UseQueryOptionsGeneric<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey,\n      TPageParam\n    >\n  >,\n  queryClient?: QueryClient,\n): UseBaseQueryReturnType<TData, TError> {\n  if (process.env.NODE_ENV === 'development') {\n    if (!getCurrentScope()) {\n      console.warn(\n        'vue-query composable like \"useQuery()\" should only be used inside a \"setup()\" function or a running effect scope. They might otherwise lead to memory leaks.',\n      )\n    }\n  }\n\n  const client = queryClient || useQueryClient()\n\n  const defaultedOptions = computed(() => {\n    const clonedOptions = cloneDeepUnref(options as any)\n\n    if (typeof clonedOptions.enabled === 'function') {\n      clonedOptions.enabled = clonedOptions.enabled()\n    }\n\n    const defaulted: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    > = client.defaultQueryOptions(clonedOptions)\n\n    defaulted._optimisticResults = client.isRestoring?.value\n      ? 'isRestoring'\n      : 'optimistic'\n\n    return defaulted\n  })\n\n  const observer = new Observer(client, defaultedOptions.value)\n  // @ts-expect-error\n  const state = defaultedOptions.value.shallow\n    ? shallowReactive(observer.getCurrentResult())\n    : reactive(observer.getCurrentResult())\n\n  let unsubscribe = () => {\n    // noop\n  }\n\n  if (client.isRestoring) {\n    watch(\n      client.isRestoring,\n      (isRestoring) => {\n        if (!isRestoring) {\n          unsubscribe()\n          unsubscribe = observer.subscribe((result) => {\n            updateState(state, result)\n          })\n        }\n      },\n      { immediate: true },\n    )\n  }\n\n  const updater = () => {\n    observer.setOptions(defaultedOptions.value)\n    updateState(state, observer.getCurrentResult())\n  }\n\n  watch(defaultedOptions, updater)\n\n  onScopeDispose(() => {\n    unsubscribe()\n  })\n\n  // fix #5910\n  const refetch = (...args: Parameters<(typeof state)['refetch']>) => {\n    updater()\n    return state.refetch(...args)\n  }\n\n  const suspense = () => {\n    return new Promise<QueryObserverResult<TData, TError>>(\n      (resolve, reject) => {\n        let stopWatch = () => {\n          // noop\n        }\n        const run = () => {\n          if (defaultedOptions.value.enabled !== false) {\n            // fix #6133\n            observer.setOptions(defaultedOptions.value)\n            const optimisticResult = observer.getOptimisticResult(\n              defaultedOptions.value,\n            )\n            if (optimisticResult.isStale) {\n              stopWatch()\n              observer\n                .fetchOptimistic(defaultedOptions.value)\n                .then(resolve, (error: TError) => {\n                  if (\n                    shouldThrowError(defaultedOptions.value.throwOnError, [\n                      error,\n                      observer.getCurrentQuery(),\n                    ])\n                  ) {\n                    reject(error)\n                  } else {\n                    resolve(observer.getCurrentResult())\n                  }\n                })\n            } else {\n              stopWatch()\n              resolve(optimisticResult)\n            }\n          }\n        }\n\n        run()\n\n        stopWatch = watch(defaultedOptions, run)\n      },\n    )\n  }\n\n  // Handle error boundary\n  watch(\n    () => state.error,\n    (error) => {\n      if (\n        state.isError &&\n        !state.isFetching &&\n        shouldThrowError(defaultedOptions.value.throwOnError, [\n          error as TError,\n          observer.getCurrentQuery(),\n        ])\n      ) {\n        throw error\n      }\n    },\n  )\n\n  // @ts-expect-error\n  const readonlyState = defaultedOptions.value.shallow\n    ? shallowReadonly(state)\n    : readonly(state)\n\n  const object: any = toRefs(readonlyState)\n  for (const key in state) {\n    if (typeof state[key as keyof typeof state] === 'function') {\n      object[key] = state[key as keyof typeof state]\n    }\n  }\n\n  object.suspense = suspense\n  object.refetch = refetch\n\n  return object as UseBaseQueryReturnType<TData, TError>\n}\n"],"mappings":"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","names":[]}